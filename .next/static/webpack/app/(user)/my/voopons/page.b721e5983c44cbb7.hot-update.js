"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(user)/my/voopons/page",{

/***/ "(app-pages-browser)/./src/utils/eventFunction.js":
/*!************************************!*\
  !*** ./src/utils/eventFunction.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDistanceInMiles: function() { return /* binding */ calculateDistanceInMiles; },\n/* harmony export */   convertTo12HourFormat: function() { return /* binding */ convertTo12HourFormat; },\n/* harmony export */   countCategory: function() { return /* binding */ countCategory; },\n/* harmony export */   filterByEventDistance: function() { return /* binding */ filterByEventDistance; },\n/* harmony export */   filterEvent: function() { return /* binding */ filterEvent; },\n/* harmony export */   filterObjectsByDateRange: function() { return /* binding */ filterObjectsByDateRange; },\n/* harmony export */   filterObjectsByDateRangeMyEvents: function() { return /* binding */ filterObjectsByDateRangeMyEvents; },\n/* harmony export */   getCurrentLocation: function() { return /* binding */ getCurrentLocation; },\n/* harmony export */   hasCommonWordIgnorePunctuation: function() { return /* binding */ hasCommonWordIgnorePunctuation; },\n/* harmony export */   isDate1BeforeDate2: function() { return /* binding */ isDate1BeforeDate2; },\n/* harmony export */   truncateDescriptionByWords: function() { return /* binding */ truncateDescriptionByWords; }\n/* harmony export */ });\nconst countCategory = function() {\n    let list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], ItemList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [] // Assume category_id in ItemList is a string\n    ;\n    let returnList = [];\n    for (let el of list){\n        let count = 0;\n        for (let itemEl of ItemList){\n            if (Number(itemEl.category_id) === Number(el.category_id)) {\n                // Convert el.category_id to string for comparison\n                count += 1;\n            }\n        }\n        returnList.push({\n            ...el,\n            count: count\n        });\n    }\n    return returnList.filter((item)=>item.count !== 0);\n};\nconst filterEvent = function() {\n    let eventList = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], categoryList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    let returnList = [];\n    for (let elEvent of eventList){\n        for (let elCategory of categoryList){\n            if (Number(elCategory.category_id) === Number(elEvent.category_id)) {\n                returnList.push(elEvent);\n            }\n        }\n    }\n    return returnList;\n};\nconst convertTo12HourFormat = (time24hr)=>{\n    const [hours, minutes] = time24hr.split(\":\").map(Number);\n    if (isNaN(hours) || hours < 0 || hours > 23) {\n        return \"Invalid time format\";\n    }\n    const period = hours >= 12 ? \"PM\" : \"AM\";\n    const hours12 = hours % 12 || 12; // Convert 0 to 12\n    if (!isNaN(minutes) && minutes >= 0 && minutes <= 59) {\n        return \"\".concat(String(hours12).padStart(2, \"0\"), \":\").concat(String(minutes).padStart(2, \"0\"), \" \").concat(period);\n    } else {\n        return \"\".concat(String(hours12).padStart(2, \"0\"), \":\").concat(String(0).padStart(2, \"0\"), \" \").concat(period);\n    }\n};\n// export function getCurrentLocation() {\n//   return (\n//     new Promise() <\n//     Coordinates >\n//     ((resolve, reject) => {\n//       navigator.geolocation.getCurrentPosition(\n//         (position) => resolve(position.coords),\n//         (error) => reject(error)\n//       );\n//     })\n//   );\n// }\nfunction getCurrentLocation() {\n    return new Promise((resolve, reject)=>{\n        navigator.geolocation.getCurrentPosition((position)=>resolve(position.coords), (error)=>reject(error));\n    });\n}\nfunction calculateDistanceInMiles(coord1, coord2) {\n    const R = 6371; // Radius of the Earth in kilometers\n    const lat1 = toRadians(coord1.latitude);\n    const lat2 = toRadians(coord2.longitude);\n    const deltaLat = toRadians(coord2.latitude - coord1.latitude);\n    const deltaLng = toRadians(coord2.longitude - coord1.longitude);\n    const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distanceInKm = R * c; // Distance in kilometers\n    const distanceInMiles = distanceInKm * 0.621371; // Convert to miles\n    return +distanceInMiles.toFixed(2);\n}\nfunction toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n}\nfunction filterObjectsByDateRange(date1, date2, objectsList) {\n    const startDate = new Date(date1);\n    const endDate = new Date(date2);\n    // Ensure that the dates are valid\n    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {\n        throw new Error(\"Invalid date format\");\n    }\n    return objectsList.filter((obj)=>{\n        const objDate = new Date(obj.events_date);\n        return objDate >= startDate && objDate <= endDate;\n    });\n}\nfunction filterObjectsByDateRangeMyEvents(date1, date2, objectsList, keyText) {\n    const startDate = new Date(date1);\n    const endDate = new Date(date2);\n    // Ensure that the dates are valid\n    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {\n        throw new Error(\"Invalid date format\");\n    }\n    return objectsList.filter((obj)=>{\n        var _obj_keyText;\n        const objDate = new Date(obj === null || obj === void 0 ? void 0 : (_obj_keyText = obj[keyText]) === null || _obj_keyText === void 0 ? void 0 : _obj_keyText.events_date);\n        return objDate >= startDate && objDate <= endDate;\n    });\n}\nfunction isDate1BeforeDate2(date1, date2) {\n    const date1Obj = new Date(date1.replace(/-/g, \"/\"));\n    const date2Obj = new Date(date2.replace(/-/g, \"/\"));\n    // Compare the two Date objects\n    return date1Obj < date2Obj;\n}\nfunction hasCommonWordIgnorePunctuation(str1, str2) {\n    // Check if either statement is empty\n    if (str1.trim() === \"\" || str2.trim() === \"\") {\n        return false;\n    }\n    // Helper function to remove punctuation from a word\n    const removePunctuation = (word)=>{\n        return word.replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]/g, \"\");\n    };\n    // Split the strings into arrays of words and remove punctuation\n    const words1 = str1.split(/\\s+/).map(removePunctuation);\n    const words2 = str2.split(/\\s+/).map(removePunctuation);\n    // Check for common words\n    const commonWords = words1.filter((word)=>words2.includes(word));\n    // Return true if there are common words, otherwise false\n    return commonWords.length > 0;\n}\nfunction filterByEventDistance(list, from, to) {\n    const filteredList = list.filter((item)=>{\n        const distance = item.event_away_distance;\n        return distance !== undefined && distance >= from && distance <= to;\n    });\n    return filteredList;\n}\n// code written by rajan\nconst truncateDescriptionByWords = (text, maxLength)=>{\n    if (!text) return \"\";\n    return text.length > maxLength ? text.substring(0, maxLength) + \"...\" : text;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ldmVudEZ1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQU8sTUFBTUEsZ0JBQWdCO1FBQzNCQyx3RUFBTyxFQUFFLEVBQ1RDLDRFQUFXLEVBQUUsQ0FBQyw2Q0FBNkM7O0lBRTNELElBQUlDLGFBQWEsRUFBRTtJQUVuQixLQUFLLElBQUlDLE1BQU1ILEtBQU07UUFDbkIsSUFBSUksUUFBUTtRQUVaLEtBQUssSUFBSUMsVUFBVUosU0FBVTtZQUMzQixJQUFJSyxPQUFPRCxPQUFPRSxXQUFXLE1BQU1ELE9BQU9ILEdBQUdJLFdBQVcsR0FBRztnQkFDekQsa0RBQWtEO2dCQUNsREgsU0FBUztZQUNYO1FBQ0Y7UUFFQUYsV0FBV00sSUFBSSxDQUFDO1lBQUUsR0FBR0wsRUFBRTtZQUFFQyxPQUFPQTtRQUFNO0lBQ3hDO0lBRUEsT0FBT0YsV0FBV08sTUFBTSxDQUFDLENBQUNDLE9BQVNBLEtBQUtOLEtBQUssS0FBSztBQUNwRCxFQUFFO0FBRUssTUFBTU8sY0FBYztRQUFDQyw2RUFBWSxFQUFFLEVBQUVDLGdGQUFlLEVBQUU7SUFDM0QsSUFBSVgsYUFBYSxFQUFFO0lBRW5CLEtBQUssSUFBSVksV0FBV0YsVUFBVztRQUM3QixLQUFLLElBQUlHLGNBQWNGLGFBQWM7WUFDbkMsSUFBSVAsT0FBT1MsV0FBV1IsV0FBVyxNQUFNRCxPQUFPUSxRQUFRUCxXQUFXLEdBQUc7Z0JBQ2xFTCxXQUFXTSxJQUFJLENBQUNNO1lBQ2xCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9aO0FBQ1QsRUFBRTtBQUVLLE1BQU1jLHdCQUF3QixDQUFDQztJQUNwQyxNQUFNLENBQUNDLE9BQU9DLFFBQVEsR0FBR0YsU0FBU0csS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQ2Y7SUFFakQsSUFBSWdCLE1BQU1KLFVBQVVBLFFBQVEsS0FBS0EsUUFBUSxJQUFJO1FBQzNDLE9BQU87SUFDVDtJQUVBLE1BQU1LLFNBQVNMLFNBQVMs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TUMsZUFBZTVGLEtBQUtTLE1BQU0sQ0FBQyxDQUFDQztRQUNoQyxNQUFNbUYsV0FBV25GLEtBQUtvRixtQkFBbUI7UUFDekMsT0FBT0QsYUFBYUUsYUFBYUYsWUFBWUgsUUFBUUcsWUFBWUY7SUFDbkU7SUFFQSxPQUFPQztBQUNUO0FBRUEsd0JBQXdCO0FBRWpCLE1BQU1JLDZCQUE2QixDQUFDQyxNQUFNQztJQUMvQyxJQUFJLENBQUNELE1BQU0sT0FBTztJQUNsQixPQUFPQSxLQUFLVCxNQUFNLEdBQUdVLFlBQVlELEtBQUtFLFNBQVMsQ0FBQyxHQUFHRCxhQUFhLFFBQVFEO0FBQzFFLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2V2ZW50RnVuY3Rpb24uanM/NjBmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY291bnRDYXRlZ29yeSA9IChcclxuICBsaXN0ID0gW10sXHJcbiAgSXRlbUxpc3QgPSBbXSAvLyBBc3N1bWUgY2F0ZWdvcnlfaWQgaW4gSXRlbUxpc3QgaXMgYSBzdHJpbmdcclxuKSA9PiB7XHJcbiAgbGV0IHJldHVybkxpc3QgPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgZWwgb2YgbGlzdCkge1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtRWwgb2YgSXRlbUxpc3QpIHtcclxuICAgICAgaWYgKE51bWJlcihpdGVtRWwuY2F0ZWdvcnlfaWQpID09PSBOdW1iZXIoZWwuY2F0ZWdvcnlfaWQpKSB7XHJcbiAgICAgICAgLy8gQ29udmVydCBlbC5jYXRlZ29yeV9pZCB0byBzdHJpbmcgZm9yIGNvbXBhcmlzb25cclxuICAgICAgICBjb3VudCArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuTGlzdC5wdXNoKHsgLi4uZWwsIGNvdW50OiBjb3VudCB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXR1cm5MaXN0LmZpbHRlcigoaXRlbSkgPT4gaXRlbS5jb3VudCAhPT0gMCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZmlsdGVyRXZlbnQgPSAoZXZlbnRMaXN0ID0gW10sIGNhdGVnb3J5TGlzdCA9IFtdKSA9PiB7XHJcbiAgbGV0IHJldHVybkxpc3QgPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgZWxFdmVudCBvZiBldmVudExpc3QpIHtcclxuICAgIGZvciAobGV0IGVsQ2F0ZWdvcnkgb2YgY2F0ZWdvcnlMaXN0KSB7XHJcbiAgICAgIGlmIChOdW1iZXIoZWxDYXRlZ29yeS5jYXRlZ29yeV9pZCkgPT09IE51bWJlcihlbEV2ZW50LmNhdGVnb3J5X2lkKSkge1xyXG4gICAgICAgIHJldHVybkxpc3QucHVzaChlbEV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJldHVybkxpc3Q7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29udmVydFRvMTJIb3VyRm9ybWF0ID0gKHRpbWUyNGhyKSA9PiB7XHJcbiAgY29uc3QgW2hvdXJzLCBtaW51dGVzXSA9IHRpbWUyNGhyLnNwbGl0KFwiOlwiKS5tYXAoTnVtYmVyKTtcclxuXHJcbiAgaWYgKGlzTmFOKGhvdXJzKSB8fCBob3VycyA8IDAgfHwgaG91cnMgPiAyMykge1xyXG4gICAgcmV0dXJuIFwiSW52YWxpZCB0aW1lIGZvcm1hdFwiO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcGVyaW9kID0gaG91cnMgPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCI7XHJcbiAgY29uc3QgaG91cnMxMiA9IGhvdXJzICUgMTIgfHwgMTI7IC8vIENvbnZlcnQgMCB0byAxMlxyXG5cclxuICBpZiAoIWlzTmFOKG1pbnV0ZXMpICYmIG1pbnV0ZXMgPj0gMCAmJiBtaW51dGVzIDw9IDU5KSB7XHJcbiAgICByZXR1cm4gYCR7U3RyaW5nKGhvdXJzMTIpLnBhZFN0YXJ0KDIsIFwiMFwiKX06JHtTdHJpbmcobWludXRlcykucGFkU3RhcnQoXHJcbiAgICAgIDIsXHJcbiAgICAgIFwiMFwiXHJcbiAgICApfSAke3BlcmlvZH1gO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gYCR7U3RyaW5nKGhvdXJzMTIpLnBhZFN0YXJ0KDIsIFwiMFwiKX06JHtTdHJpbmcoMCkucGFkU3RhcnQoXHJcbiAgICAgIDIsXHJcbiAgICAgIFwiMFwiXHJcbiAgICApfSAke3BlcmlvZH1gO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIG5ldyBQcm9taXNlKCkgPFxyXG4vLyAgICAgQ29vcmRpbmF0ZXMgPlxyXG4vLyAgICAgKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuLy8gICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcclxuLy8gICAgICAgICAocG9zaXRpb24pID0+IHJlc29sdmUocG9zaXRpb24uY29vcmRzKSxcclxuLy8gICAgICAgICAoZXJyb3IpID0+IHJlamVjdChlcnJvcilcclxuLy8gICAgICAgKTtcclxuLy8gICAgIH0pXHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcclxuICAgICAgKHBvc2l0aW9uKSA9PiByZXNvbHZlKHBvc2l0aW9uLmNvb3JkcyksXHJcbiAgICAgIChlcnJvcikgPT4gcmVqZWN0KGVycm9yKVxyXG4gICAgKTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlSW5NaWxlcyhjb29yZDEsIGNvb3JkMikge1xyXG4gIGNvbnN0IFIgPSA2MzcxOyAvLyBSYWRpdXMgb2YgdGhlIEVhcnRoIGluIGtpbG9tZXRlcnNcclxuXHJcbiAgY29uc3QgbGF0MSA9IHRvUmFkaWFucyhjb29yZDEubGF0aXR1ZGUpO1xyXG4gIGNvbnN0IGxhdDIgPSB0b1JhZGlhbnMoY29vcmQyLmxvbmdpdHVkZSk7XHJcbiAgY29uc3QgZGVsdGFMYXQgPSB0b1JhZGlhbnMoY29vcmQyLmxhdGl0dWRlIC0gY29vcmQxLmxhdGl0dWRlKTtcclxuICBjb25zdCBkZWx0YUxuZyA9IHRvUmFkaWFucyhjb29yZDIubG9uZ2l0dWRlIC0gY29vcmQxLmxvbmdpdHVkZSk7XHJcblxyXG4gIGNvbnN0IGEgPVxyXG4gICAgTWF0aC5zaW4oZGVsdGFMYXQgLyAyKSAqIE1hdGguc2luKGRlbHRhTGF0IC8gMikgK1xyXG4gICAgTWF0aC5jb3MobGF0MSkgKlxyXG4gICAgICBNYXRoLmNvcyhsYXQyKSAqXHJcbiAgICAgIE1hdGguc2luKGRlbHRhTG5nIC8gMikgKlxyXG4gICAgICBNYXRoLnNpbihkZWx0YUxuZyAvIDIpO1xyXG5cclxuICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcclxuXHJcbiAgY29uc3QgZGlzdGFuY2VJbkttID0gUiAqIGM7IC8vIERpc3RhbmNlIGluIGtpbG9tZXRlcnNcclxuICBjb25zdCBkaXN0YW5jZUluTWlsZXMgPSBkaXN0YW5jZUluS20gKiAwLjYyMTM3MTsgLy8gQ29udmVydCB0byBtaWxlc1xyXG5cclxuICByZXR1cm4gK2Rpc3RhbmNlSW5NaWxlcy50b0ZpeGVkKDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xyXG4gIHJldHVybiBkZWdyZWVzICogKE1hdGguUEkgLyAxODApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyT2JqZWN0c0J5RGF0ZVJhbmdlKGRhdGUxLCBkYXRlMiwgb2JqZWN0c0xpc3QpIHtcclxuICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlMSk7XHJcbiAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKGRhdGUyKTtcclxuXHJcbiAgLy8gRW5zdXJlIHRoYXQgdGhlIGRhdGVzIGFyZSB2YWxpZFxyXG4gIGlmIChpc05hTihzdGFydERhdGUuZ2V0VGltZSgpKSB8fCBpc05hTihlbmREYXRlLmdldFRpbWUoKSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXRcIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqZWN0c0xpc3QuZmlsdGVyKChvYmopID0+IHtcclxuICAgIGNvbnN0IG9iakRhdGUgPSBuZXcgRGF0ZShvYmouZXZlbnRzX2RhdGUpO1xyXG4gICAgcmV0dXJuIG9iakRhdGUgPj0gc3RhcnREYXRlICYmIG9iakRhdGUgPD0gZW5kRGF0ZTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlck9iamVjdHNCeURhdGVSYW5nZU15RXZlbnRzKFxyXG4gIGRhdGUxLFxyXG4gIGRhdGUyLFxyXG4gIG9iamVjdHNMaXN0LFxyXG4gIGtleVRleHRcclxuKSB7XHJcbiAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoZGF0ZTEpO1xyXG4gIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZShkYXRlMik7XHJcblxyXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBkYXRlcyBhcmUgdmFsaWRcclxuICBpZiAoaXNOYU4oc3RhcnREYXRlLmdldFRpbWUoKSkgfHwgaXNOYU4oZW5kRGF0ZS5nZXRUaW1lKCkpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0XCIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iamVjdHNMaXN0LmZpbHRlcigob2JqKSA9PiB7XHJcbiAgICBjb25zdCBvYmpEYXRlID0gbmV3IERhdGUob2JqPy5ba2V5VGV4dF0/LmV2ZW50c19kYXRlKTtcclxuICAgIHJldHVybiBvYmpEYXRlID49IHN0YXJ0RGF0ZSAmJiBvYmpEYXRlIDw9IGVuZERhdGU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUxQmVmb3JlRGF0ZTIoZGF0ZTEsIGRhdGUyKSB7XHJcbiAgY29uc3QgZGF0ZTFPYmogPSBuZXcgRGF0ZShkYXRlMS5yZXBsYWNlKC8tL2csIFwiL1wiKSk7XHJcbiAgY29uc3QgZGF0ZTJPYmogPSBuZXcgRGF0ZShkYXRlMi5yZXBsYWNlKC8tL2csIFwiL1wiKSk7XHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHR3byBEYXRlIG9iamVjdHNcclxuICByZXR1cm4gZGF0ZTFPYmogPCBkYXRlMk9iajtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NvbW1vbldvcmRJZ25vcmVQdW5jdHVhdGlvbihzdHIxLCBzdHIyKSB7XHJcbiAgLy8gQ2hlY2sgaWYgZWl0aGVyIHN0YXRlbWVudCBpcyBlbXB0eVxyXG4gIGlmIChzdHIxLnRyaW0oKSA9PT0gXCJcIiB8fCBzdHIyLnRyaW0oKSA9PT0gXCJcIikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBwdW5jdHVhdGlvbiBmcm9tIGEgd29yZFxyXG4gIGNvbnN0IHJlbW92ZVB1bmN0dWF0aW9uID0gKHdvcmQpID0+IHtcclxuICAgIHJldHVybiB3b3JkLnJlcGxhY2UoL1suLFxcLyMhJCVcXF4mXFwqOzp7fT1cXC1fYH4oKV0vZywgXCJcIik7XHJcbiAgfTtcclxuXHJcbiAgLy8gU3BsaXQgdGhlIHN0cmluZ3MgaW50byBhcnJheXMgb2Ygd29yZHMgYW5kIHJlbW92ZSBwdW5jdHVhdGlvblxyXG4gIGNvbnN0IHdvcmRzMSA9IHN0cjEuc3BsaXQoL1xccysvKS5tYXAocmVtb3ZlUHVuY3R1YXRpb24pO1xyXG4gIGNvbnN0IHdvcmRzMiA9IHN0cjIuc3BsaXQoL1xccysvKS5tYXAocmVtb3ZlUHVuY3R1YXRpb24pO1xyXG5cclxuICAvLyBDaGVjayBmb3IgY29tbW9uIHdvcmRzXHJcbiAgY29uc3QgY29tbW9uV29yZHMgPSB3b3JkczEuZmlsdGVyKCh3b3JkKSA9PiB3b3JkczIuaW5jbHVkZXMod29yZCkpO1xyXG5cclxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBhcmUgY29tbW9uIHdvcmRzLCBvdGhlcndpc2UgZmFsc2VcclxuICByZXR1cm4gY29tbW9uV29yZHMubGVuZ3RoID4gMDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckJ5RXZlbnREaXN0YW5jZShsaXN0LCBmcm9tLCB0bykge1xyXG4gIGNvbnN0IGZpbHRlcmVkTGlzdCA9IGxpc3QuZmlsdGVyKChpdGVtKSA9PiB7XHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IGl0ZW0uZXZlbnRfYXdheV9kaXN0YW5jZTtcclxuICAgIHJldHVybiBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICYmIGRpc3RhbmNlID49IGZyb20gJiYgZGlzdGFuY2UgPD0gdG87XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBmaWx0ZXJlZExpc3Q7XHJcbn1cclxuXHJcbi8vIGNvZGUgd3JpdHRlbiBieSByYWphblxyXG5cclxuZXhwb3J0IGNvbnN0IHRydW5jYXRlRGVzY3JpcHRpb25CeVdvcmRzID0gKHRleHQsIG1heExlbmd0aCkgPT4ge1xyXG4gIGlmICghdGV4dCkgcmV0dXJuIFwiXCI7XHJcbiAgcmV0dXJuIHRleHQubGVuZ3RoID4gbWF4TGVuZ3RoID8gdGV4dC5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoKSArIFwiLi4uXCIgOiB0ZXh0O1xyXG59O1xyXG4iXSwibmFtZXMiOlsiY291bnRDYXRlZ29yeSIsImxpc3QiLCJJdGVtTGlzdCIsInJldHVybkxpc3QiLCJlbCIsImNvdW50IiwiaXRlbUVsIiwiTnVtYmVyIiwiY2F0ZWdvcnlfaWQiLCJwdXNoIiwiZmlsdGVyIiwiaXRlbSIsImZpbHRlckV2ZW50IiwiZXZlbnRMaXN0IiwiY2F0ZWdvcnlMaXN0IiwiZWxFdmVudCIsImVsQ2F0ZWdvcnkiLCJjb252ZXJ0VG8xMkhvdXJGb3JtYXQiLCJ0aW1lMjRociIsImhvdXJzIiwibWludXRlcyIsInNwbGl0IiwibWFwIiwiaXNOYU4iLCJwZXJpb2QiLCJob3VyczEyIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm5hdmlnYXRvciIsImdlb2xvY2F0aW9uIiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwicG9zaXRpb24iLCJjb29yZHMiLCJlcnJvciIsImNhbGN1bGF0ZURpc3RhbmNlSW5NaWxlcyIsImNvb3JkMSIsImNvb3JkMiIsIlIiLCJsYXQxIiwidG9SYWRpYW5zIiwibGF0aXR1ZGUiLCJsYXQyIiwibG9uZ2l0dWRlIiwiZGVsdGFMYXQiLCJkZWx0YUxuZyIsImEiLCJNYXRoIiwic2luIiwiY29zIiwiYyIsImF0YW4yIiwic3FydCIsImRpc3RhbmNlSW5LbSIsImRpc3RhbmNlSW5NaWxlcyIsInRvRml4ZWQiLCJkZWdyZWVzIiwiUEkiLCJmaWx0ZXJPYmplY3RzQnlEYXRlUmFuZ2UiLCJkYXRlMSIsImRhdGUyIiwib2JqZWN0c0xpc3QiLCJzdGFydERhdGUiLCJEYXRlIiwiZW5kRGF0ZSIsImdldFRpbWUiLCJFcnJvciIsIm9iaiIsIm9iakRhdGUiLCJldmVudHNfZGF0ZSIsImZpbHRlck9iamVjdHNCeURhdGVSYW5nZU15RXZlbnRzIiwia2V5VGV4dCIsImlzRGF0ZTFCZWZvcmVEYXRlMiIsImRhdGUxT2JqIiwicmVwbGFjZSIsImRhdGUyT2JqIiwiaGFzQ29tbW9uV29yZElnbm9yZVB1bmN0dWF0aW9uIiwic3RyMSIsInN0cjIiLCJ0cmltIiwicmVtb3ZlUHVuY3R1YXRpb24iLCJ3b3JkIiwid29yZHMxIiwid29yZHMyIiwiY29tbW9uV29yZHMiLCJpbmNsdWRlcyIsImxlbmd0aCIsImZpbHRlckJ5RXZlbnREaXN0YW5jZSIsImZyb20iLCJ0byIsImZpbHRlcmVkTGlzdCIsImRpc3RhbmNlIiwiZXZlbnRfYXdheV9kaXN0YW5jZSIsInVuZGVmaW5lZCIsInRydW5jYXRlRGVzY3JpcHRpb25CeVdvcmRzIiwidGV4dCIsIm1heExlbmd0aCIsInN1YnN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/eventFunction.js\n"));

/***/ })

});